% load hkl file and do following things:
% 1, rearrage it into 3D volumn array in reciprocal space.
% 2, do inverse Fourier Transform to get obj
% 3, pad zeros around the cell to get a larger cell.

% Compared with 2nd version.
% 1, This version generate a triple cell by padding zeros up and down a
% unit cell with complex numbers.
% 2, The hkl in reciprocal space is generated by FFT of the complex triple
% cell
% 3, The starting object is the real part from the complex triple cell

% First created by Yun Zhao in Mar 02, 2015
% Last editted by Yun Zhao in Mar 02, 2015

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start. Give hkl files, including phases
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 prompts = ' Please give a input hkl file (with all positive and negative hkl values): \n';
 hkl_file_name = input(prompts,'s');
 if isempty(hkl_file_name)
     hkl_file_name = '3rdx_full_1A.hkl';
 end
 M=dlmread(hkl_file_name); % for the hkl file, you may need to delete the 
                           %  first and last line and save it as txt.
 hkl = int32(M(:,1:3)); % save hkl in a new matrix and convert it into integers.
                         % convert float hkl index to integer.
 F = M(:,4);  % extract intensity
%  F_000 = 50*max(F); % Here I use the maximum F to approaximate F_000.
F_000=0;
 F1 = 100*F/norm(F);
 phase = M(:,5);
 F_comp = F.*exp(1j.*phase*pi/180);
 % B =100* abs(log(F))/(norm(abs(log(F)))); %log scale
 [L_M, W_M]=size(M);
%  
 h_max = max(hkl(:,1));
 k_max = max(hkl(:,2));
 l_max = max(hkl(:,3));
% h_max = 28;
% k_max = 28;
 
 
 Rec_lattice = zeros(2*h_max+1,2*k_max+1,2*l_max+1);
 
 % Create a mask for futhur R factor calculation
 Rec_lattice_mask = zeros(2*h_max+1,2*k_max+1,2*l_max+1);
 
 for i=1:L_M
     h = int32(hkl(i,1)+h_max+1);
     k = int32(hkl(i,2)+k_max+1);
     l = int32(hkl(i,3)+l_max+1);
     Rec_lattice(h,k,l) = F_comp(i);
     Rec_lattice_mask(h,k,l) = 1;
 end
 
 Rec_lattice(h_max+1,k_max+1,l_max+1)=F_000;
 save('rec_lattice_1A.mat','Rec_lattice');
 save('rec_lattice_mask_1A.mat','Rec_lattice_mask');


 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Do inverse Fourier transform to get obj
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  Rec_lattice_shift = fftshift(Rec_lattice);
%  unit_cell = abs(ifftn(Rec_lattice_shift));
%  %unit_cell_1 = fftshift(unit_cell);
% %  unit_cell_complex = ifftn(Rec_lattice);
% %  unit_cell_complex_shift = fftshift(unit_cell_complex);
% %  unit_cell = abs(unit_cell_complex_shift);
% %  save('unit_cell.mat','unit_cell');

 unit_cell_complex = ifftn(ifftshift(Rec_lattice));%for any FFT, the first number [111] in matrix is always (000) in real space.
 unit_cell_real = fftshift(real(unit_cell_complex));
%  save('unit_cell_real_ifftshift_1A.mat','unit_cell_real');
%  save('unit_cell_imag_ifftshift.mat','unit_cell_imag');
 save('unit_cell_real_1A.mat','unit_cell_real');

%  unit_cell_complex = ifftn(fftshift(Rec_lattice));
%  unit_cell = real(unit_cell_complex);
%  save('unit_cell_real_fftshift.mat','unit_cell');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% shift the density peak at zero.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [s_a,s_b,s_c]=size(unit_cell_real);
% n_obj = s_a*s_b*s_c;
% rho_1d = reshape(unit_cell_abs,1,n_obj);
% rho_1d_sort = sort(rho_1d);
% rho_min = min(rho_1d);
% rho_max = max(rho_1d);
% 
% n_sampling = 1000;
% rho_0 = (rho_max-rho_min)/n_sampling;
% n_count = zeros(1,n_sampling+1);
% x_I_abs = linspace(rho_min,rho_max,n_sampling+1);
% x_I_voxel = linspace(1,n_obj,n_obj);
% 
% for i = 1:n_obj
%     f_ratio = (rho_1d(i)-rho_min)/rho_0;
%     f_floor = floor(f_ratio);
%     f_ceil = f_floor+1;
%     f_fraction = f_ratio - f_floor;
%     n_count(f_ceil) = n_count(f_ceil) + 1;
% end
% 
% [n_count_max,n_max_location]=max(n_count);
% % rho_shift = x_I_abs(n_max_location); % Shift to zero
% rho_shift = 0; % Without any shift
% 
% unit_cell_shift = unit_cell_real - rho_shift;
% x_I_abs_shift = x_I_abs - rho_shift;
% rho_1d_sort_shift = rho_1d_sort - rho_shift;

% save('unit_cell_shift_1A.mat','unit_cell_shift');
% save('rho_shift_1A.mat','rho_shift');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check density distribution for shifted obj
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% figure(2);
% plt2=plot(x_I_abs_shift,n_count,'r');
% % xlim([0,ceil(rho_max/rho_sigma)]);
% xlabel('charge density','FontSize', 15,'FontWeight','bold');
% ylabel('voxel counts','FontSize', 15,'FontWeight','bold');
% title('charge density distribution within unit cell','FontSize', 15,'FontWeight','bold');
% %  saveas(plt2,'density_distribution_real_ifftshift_1A.tif');
% % saveas(plt2,'density_distribution_real_fftshift.tif');
% % saveas(plt2,'density_distribution_abs.tif');
% 
% figure(3)
% plt3=plot(x_I_voxel,rho_1d_sort_shift,'m');
% xlim([1,ceil(n_obj*1.1)]);
% xlabel('pixel number','FontSize', 15,'FontWeight','bold');
% ylabel('charge density','FontSize', 15,'FontWeight','bold');
% title('sorted charge density over voxel number','FontSize', 15,'FontWeight','bold');
% %  saveas(plt3,'density_distribution_sorted_voxel_abs_ifftshift_1A.tif');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%  % Triple in c direction
[s_a,s_b,s_c]=size(unit_cell_real);
obj_triple_c_complex = zeros(s_a,s_b,3*s_c-2);
support_c = zeros(s_a,s_b,3*s_c-2);
obj_triple_c_complex(:,:,s_c:2*s_c-1) = unit_cell_complex;
obj_triple_c_real = real(obj_triple_c_complex);
support_c(:,:,s_c:2*s_c-1) = ones(s_a,s_b,s_c);
save('obj_complex_triple_1A.mat','obj_triple_c_real');
save('support_triple_1A.mat','support_c');
 
% Generate hkl file for triple cell.
rec_tri_lat_complex = fftn(obj_triple_c_complex);
rec_tri_lat_mag = abs(rec_tri_lat_complex);
rec_tri_lat_ang = angle(rec_tri_lat_complex);
rec_tri_lat_mag_centered = fftshift(rec_tri_lat_mag);
save('rec_tri_lat_mag_1A.mat','rec_tri_lat_mag');
save('rec_tri_lat_ang_1A.mat','rec_tri_lat_ang');
save('rec_tri_lat_mag_1A_centered.mat','rec_tri_lat_mag_centered'); 
